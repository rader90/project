https://www.youtube.com/watch?v=qSHP98i9mDU&list=PL0lO_mIqDDFXNfqIL9PHQM7Wg_kOtDZsW
https://programming086.blogspot.com/2012/12/lecture-cpp-1.html
https://ravesli.com/uroki-cpp/



https://ru.stackoverflow.com
http://www.cyberforum.ru
https://toster.ru/tags/firsttime
https://docs.microsoft.com/ru-ru/cpp/error-messages/compiler-errors-1/c-cpp-build-errors?view=vs-2017

Алгоритм – порядок действий, которые необходимо выполнить для решения определенной задачи.

Cтейтмент (англ. «statement») – это наиболее распространённый тип инструкций в программах. 
Это и есть та самая инструкция, наименьшая независимая единица в языке С++. 
Стейтмент в программировании – это то же самое, что и предложение в русском языке. 
Мы пишем предложения, чтобы выразить какую-то идею. В C++ мы пишем стейтменты, чтобы выполнить какое-то задание. 
Все стейтменты в C++ заканчиваются точкой с запятой.

В C++ стейтменты объединяются в блоки – функции. Функция – это последовательность стейтментов. 
Каждая программа в C++ должна содержать главную функцию main(). Именно с первого стейтмента в main() и начинается выполнение программы. 
Функции, как правило, выполняют конкретное задание. Например, функция max() может содержать стейтменты,
 которые определяют максимальное число из заданных двух. Функция calculateGrade() может рассчитывать оценку студента. 
 Более детально об этом мы ещё поговорим в следующих уроках.
Совет: Пишите функцию main() в файле .cpp с тем же именем, что и проект. 
Например, если вы пишите программу Chess, то поместите вашу функцию main() в chess.cpp.


Библиотека – это набор скомпилированного кода (например, функций), который был «упакован» для повторного использования в других программах.
Стандартной библиотекой С++, которая предоставляет дополнительный функционал. 
Одной из наиболее часто используемых частей стандартной библиотеки C++ является библиотека iostream, 
которая позволяет выводить данные на экран и обрабатывать пользовательский ввод.

Стейтмент – это «полное предложение», которое сообщает компилятору, что ему нужно выполнить определённое задание. 
Выражение производит результат и используется внутри стейтментов.

Функция – это последовательность стейтментов. 
Библиотека – это последовательность функций, которые могут повторно использоваться в других программах.

Во-первых, на уровне библиотек/программ/функций комментарии отвечают на вопрос «ЧТО?»: «Что делают эти библиотеки/программы/функции?». 
Во-вторых, внутри библиотек/программ/функций комментарии отвечают на вопрос «КАК?»
В-третьих, на уровне стейтментов (однострочного кода) комментарии отвечают на вопрос «ПОЧЕМУ?»

Функция – это последовательность стейтментов для выполнения определённого задания. 
Часто ваши программы будут прерывать выполнение одних функций ради выполнения других.
 Вы делаете аналогичные вещи в реальной жизни постоянно. Например, вы читаете книгу и вспомнили, что должны были сделать телефонный звонок.
 Вы оставляете закладку в своей книге, берёте телефон и набираете номер. 
После того, как вы уже поговорили, вы возвращаетесь к чтению: к той странице, на которой остановились.
Начинающие программисты часто спрашивают: «А можно ли обходиться без функций и весь код помещать непосредственно в функцию main()?». 
Если вашего кода всего 10-20 строчек, то можно, если же серьёзно, то функции предназначены для упрощения кода, а не для его усложнения. 
Они имеют ряд преимуществ, которые делают их чрезвычайно полезными в нетривиальных программах.

   Структура. Как только программы увеличиваются в размере/сложности, сохранять весь код внутри main() становится трудно.
   Функция — это как мини-программа, которую мы можем записать отдельно от головной программы, не заморачиваясь при этом об остальных частях кода. 
   Это позволяет разбивать сложные задачи на более мелкие и простые, что кардинально снижает общую сложность программы.

   Повторное использование. После объявления функции, её можно вызывать много раз. 
   Это позволяет избежать дублирования кода и сводит к минимуму вероятность возникновения ошибок при копировании/вставке кода. 
   Функции также могут использоваться и в других программах, уменьшая объём кода, который нужно писать с нуля каждый раз.

   Тестирование. Поскольку функции убирают лишний код, то и тестировать его становится проще. 
   А так как функция — это самостоятельная единица, то нам достаточно протестировать её один раз, чтобы убедиться в её работоспособности, 
   а затем мы можем её повторно использовать много раз без необходимости проводить тестирование (до тех пор, пока не внесём изменения в эту функцию).

   Модернизация. Когда нужно внести изменения в программу или расширить её функционал, то функции являются отличным вариантом. 
   С их помощью можно внести изменения в одном месте, чтобы они работали везде.

   Абстракция. Для того, чтобы использовать функцию, нам нужно знать её имя, данные ввода, данные вывода и где эта функция находится. 
   Нам не нужно знать, как она работает. Это очень полезно для написания кода, 
   понятного другим (например, стандартная библиотека С++ и всё, что в ней находится, создана по этому принципу).
Одной из наиболее распространённых проблем, с которой сталкиваются новички, является понимание того, где, когда и как эффективно использовать функции. 
Вот несколько основных рекомендаций при написании функций:

   Код, который появляется более одного раза в программе, лучше переписать в виде функции. 
   Например, если мы получаем данные от пользователя несколько раз одним и тем же способом, то это отличный вариант для написания отдельной функции.

   Код, который используется для сортировки чего-либо, лучше записать в виде отдельной функции. 
   Например, если у нас есть список вещей, которые нужно отсортировать — пишем функцию сортировки, 
   куда передаём несортированный список и откуда получаем отсортированный.

   Функция должна выполнять одно (и только одно) задание.

   Когда функция становится слишком большой, сложной или непонятной – её следует разбить на несколько подфункций. 
   Это называется рефакторинг кода.
   
 Представьте себе Вашу файловую систему без каталогов - всё в корневике (в глобальном пространстве имен).
Какие проблемы могут возникнуть? 
Самое первое - нельзя иметь два файла с одним именем на самом деле можно, но сейчас не об этом потому как возникнет конфликт имен.
Теперь допустим, что всё же у нас два разных файла с одним именем (файл1) оказались в корневике и Вам начальник со свирепым выражением лица,
 крича и разбрызгивая во все стороны свою слюну кричит "Открой файл1", но вот беда - их два и какой открывать? 
 У Вас по сути один нормальный путь - спросить какой именно, собственно компилятор так и делает - выдает ошибку 
 с текстом на подобии "Имя 'такое-то' двусмысленно".
А если бы всё лежало по папкам, то коллизий бы не возникло.
Вам бы сказали открыть файл "файл1" из каталога "каталог1" ( каталог1::файл1 )
или открыть файл "файл1" из каталога "каталог2" ( каталог2::файл1 )

А теперь к примеру на программе:
А теперь представьте, что написали Вы программу, всё работает - класс, всё довольны!
И вот решили вдруг, что нужно еще сделать пару фишек. Нашли стороннюю библиотеку, 
которая отлично подходит для реализации этих самых "фишек", но вот беда в ней есть классы с таким же именем как и у Вас. 
Что делать? Создавать копию Вашего класса, но с другим именем? Ну это жестко.
Вот пространства имен призваны решать такие проблемы. Например, вся стандартная библиотека, содержится в одном пространстве имен std, 
а подключаемые файлы так же определяют свои пространства имен, например библиотека boost находится в пространстве имен boost. Если писать boost::vector, 
то будет понятно, что используется вектор из библиотеки boost, а не std.
Что касается using namespace такое-то, это означает примерно следующее:
"Использовать пространство имен такое-то в этой области видимости". 
То есть мы "скидываем" всё содержимое пространства имен в "текущую" область видимости, тем самым её засоряя 
( пример про корневой каталог без разделения на папки ).

То есть пространства имен можно рассматривать как уточнение имени сущности.



В C++ вы можете объявить переменную и присвоить ей значение одновременно. Это называется инициализацией (или ещё «определением»).
Определение фактически реализует (вызывает выделение памяти) идентификатор. 
Определение фактически реализует (вызывает выделение памяти) идентификатор. Вот примеры определений:

int add(int x, int y) // определяем функцию add()
{
    int z = x + y; // определяем переменную z

    return z;
}
В C++ есть правило одного определения, которое состоит из трёх частей:

   Внутри файла: функция, объект, тип или шаблон могут иметь только одно определение.

   Внутри программы: объект или обычная функция могут иметь только одно определение.

   Внутри программы: типы, шаблоны функций и встроенные функции могут иметь несколько определений, если они идентичны. .
   
